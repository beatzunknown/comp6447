Useful Commands

PWNDBG
GDB Commands:
	b 0x1337- break at address 1337
	c - continue until next breakpoint/end program
	si - step by a single instruction
	fin - go until end of current function
	x 0x1337 - examine at 0x1337
	x/20wx 0x1337 - examine 20 words from 0x1337
	x/s 0x1337- examine string at 0x1337
	att 1234 - attach to running process 1234
	set $reg=value - set register = value ie: set $ebx=1
Heap Commands:
	heap - view overview of heap
	bins - view current heap bins
	vis_heap_chunks 0x1234 5 - view 5 heap chunks from 0x1234. no parameter just shows all heap chunks


PWNTOOLS
	p = process("filename/path") - start local process
	p = remote("IP",PORT) - connect to remote process at IP on port
	p.recvuntil("string",timeout=0.5,drop=True/False) - receive from process until string or timeout occurs. Choose whether to drop or include the specified string.
	p.sendline("string") - send string to process -> /n included
	p.sendlineafter("incoming string", "sending string") - sends a string after receiving a string
	p32(0x12345678) = "\x78\x56\x34\x12" - pack number into little endian format
	u32("\x78\x56\x34\x12") = 0x12345678 - unpack number from little endian format to decimal
	log.info("text") - Show regular (blue) log text on screen
	log.critical("text") - Show critical (red) log text on screen
	pause() - Pause python process. we can connect gdb afterwards by using "attach pid" in gdb
	p.interactive() - Give user an interactive shell
	run `python file.py DEBUG` where debug flag shows inputs and outputs
	p.elf.symbols['func_name'] - returns the address of a symbol of a process (uses local ELF file)
	elf.address = addr - set the base address of the elf binary
	elf.got['func_name'] - returns address of the GOT entry for a function
	flat({12: data}, filler='A', length=n) - puts 12 bytes of padding and then the data. Includes option to specify the padding filler used, and the length of generated bytestring
	cyclic(n) - generate debrujin sequence of length n


UNIX
	objdump -d binary - Dump Assembly Instructions
	strace ./binary - Trace the syscalls during process execution
	ltrace ./binary- Trace the library calls during process execution
	strings binary - Print out all strings found in file
	checksec binary - Check security implemented in binary such as RELRO, stack canary, aslr, PIE
	file binary - Type of file
	rabin2 -x binary - List strings and relative addresses in data section
	xxd binary - View binary (or a collection of bytes) as hex 
	dmesg - view segmentation faults in the system
	readelf -S binary - view memory regions of the binary
	ropper -f binary - get gadgets from binary. --search "pop" to search for gadgets, --string "bin" to search for strings
	patchelf --set-interpreter /tmp/ld-2.27.so ./test

printing 0x1337 in little endian produces 70x13
first extend to 0x00001337
so then we get 0x37 0x13 0x00 0x00
but 0x37 is the hex ascii value for the character '7'
this is why it visually looks like 70x37

Memory grows down.
Memory can be visualised in 2 dimensions where the width is the size of the processor (32 or 64 bit etc)
Memory runs from top to bottom with a certain width.
Network protocols are all in little endian.
Endianness: little endian has most significant byte at the end, and big endian has most significant at the start
Rodata â€“ readonly data
Each lib is mapped into a separate text or lib section
Libs have export symbols which list the entry points for calling them

REVERSE ENGINEERING
involves breaking down how a program works without source code
needed for
	breaking copyright protection
	security testing to find vulnerabilities
	understanding malware

preprocessor (cpp): copy and paste things like macros and constants etc
compiler (gcc): converts source codes and included headers (.i, .ii) into assembly code (.s)
assembler (as): convers assembly code into machine code (.o, .obj).
linker (ld): links static libraries (.lib, .a) with the machine code, creating resultant program (.exe)

lines of c code can correspond to many possible asm code and vice versa

registers are small regions of memory on the CPU (32 bits on 32 bit architecture)
some registers have special preserved purposes while others are "general purpose" but are regularly used for particular purposes

register use conventions
AX (accumulator register) - for arithmetic operations
CX (counter register) - for shift/rotate instructions and loops
DX (data register) - for arithmetic and IO operations
BX (base register) - pointer to data (in segment register DS when in segmented mode)
SP (stack pointer register) - points to top of the stack
BP (stack base pointer register) - points to base of stack (frame). commonly referred to the "frame pointer"
SI (source index register) - used as pointer to a source in stream operations
DI (destination index register) - pointer to destination in stream operations
EIP (instruction pointer) - points to next instruction to be executed. can't be modified directly
EAX - frequently used as first parameter for function call and return value for function return
FLAGS (flags register) - special register for storing things like a zero flag

function prologue:
we preserve the old stack frame (EBP)
	PUSH EBP
	MOV EBP, ESP
we preserve room on the stack for local variables etc
	ADD ESP, 8
note that return address is usually on top of the arguments. the frame pointer will point above the return address (at preserved EBP)

function epilogue:
LEAVE
	MOV ESP, EBP
	POP EBP
RET
	POP EIP

assembly instructions
x86 instructions can be between 1 and 15 bytes long
NOP - does nothing
PUSH/POP <register> - stack manipulation
ADD/SUB <dest> <source> - dest = dest+source
JMP <offset> - jumps forward offset amount of bytes
CALL <address> - calls function at address. will push EIP onto stack as return address, and then jump to the address.

MOV (move)
	MOV eax, ebx: eax = ebx (treat ebx as value)
	MOV eax, [ebx]: eax = *ebx (treat ebx as pointer)
	MOV eax, [ebx+4]: eax = *(ebx+4) (treat ebx as pointer)
mov dword means mov double word, which moves the whole 4 bytes. mov word would just move 16 lsb

LEA (load effective address)
loads the address of the source operand into the destination. it does maths quick
LEA ebx, [ecx+4] is equivalent to:
	MOV ebx, ecx
	ADD ebx, 4

RET (return)
this is the opposite of CALL instruction. restores saved EIP from stack. it is equivalent to:
POP EIP

CMP/TEST
used for comparisons
TEST <a> <b> 
	AND's together a and b
	Sets the flags (zero flag, negative/positive flags) in EFLAGS
CMP <a> <b>
	SUB's b from a
	Sets the flag (zero flag, negative/positive flags) in EFLAGS
zero flag is set to 1 when the result is zero

test eax, eax is used to check if eax is zero

jumping
JZ - jump if zero flag set
JNZ - jump if zero flag not set
JGE - jump if greater/equal (positive or zero flag set)
JLE - jump if less/equal (negative or zero flag set)
Example of jumping to address if eax != ebx:
	CMP eax, ebx
	JNZ address
not that if (var == 0) becomes a jnz jump. if the statement isn't true it will jump to the false block of code, else it continues with the true result code.

calling conventions
we use cdecl convention
arguments are pushed onto the stack in reverse order
then the callee cleans up
return value of function is in EAX
function (a,b,c):
push c
push b
push a
call function
add esp, 12 or 0xc or 0ch (h means hexadecimal)

a would be in [ebp+8], b in [ebp+12], c in [ebp+16]

BINARY EXPLOITATION
exploitation is the process of attacking a vulneratility
buffer - array
buffer overflow - being able to write past the end of the buffer

stack cookies/canary
	place random 4 byte value between buffers and saved return address
	value is checked before RET to see if it has been overwritten
	this check is usually done with an XOR or subtraction between the canary and saved canary value (in gs) that should produce zero
	gs is an x86 segment register
	note the canary is actually a 3 byte value followed by a null byte
	so 0xffffff00 is a valid canary and in little endian \x00\xff\xff\xff
	this null byte is to prevent leaking of the canary. for example if there is a buffer on top of the canary but you write over the buffer's null byte, then the canary's own null byte will stop the buffer reading, thus not printing the canary value.

variable reordering
	make all non-arrays above arrays in stack to stop them being overwritten
	this isn't a guarantee but it helps

stack overflows alone aren't very exploitable nowadays, but can be involved within the process of exploiting

to defeat the stack canary we need to first leak the canary and then we can overflow the stack (preserving the canary value)

ASLR - address space layout randomisation
randomises stack/heap/executable/dlls/other important locations
means we can't hardcode an address and win

NX - non-executable stack

__x86_get_pc_thunk_bx
a thunk is a subrouting to inject an additional calculation into another subrouting
get_(program counter)_thunk_(e)bx
It is a way of finding the base of a binary
it is for position independent code

reverse engineering tips:
	be patient
	look for patterns (identify loops, conditionals, variable types)
	Try to get a bigger picture instead of focusing on individual instructions

conditional jumps:
	involves a CMP and a jump instruction

loops:
	are conditionals with a "goto"
	usually compiled backwards, while(x){} becomes if(x) {do {...} while (x)}

switch cases
	when theres low values consecutive:
		an array is used (jump table) which uses the case number as an index to get an address to jump to
		just 1 comparison and a jump
	when theres consecutive but larger values:
		same as previous but subtracts the smallest value (so indexing starts at 0)
		missing values will just have a pointer to the default case
	when theres complex random cases:
		gets compiled into a bunch of if/else's
		implemented with a binary search using bg
	conclusion: switch cases are more optimised than a bunch of if/else

most things in c are just ints/words in disguise (given meaning and different sizes)

movsx - sx is signed extensions so variable is signed and can be extended in length
movzx - zx is zero extension so extension is filled with zero and this is unsigned

if you don't specify size like dword, default is size of the register

how to spot a struct:
	allocations are of a fixed size
	populated using constant offsets from the base
	context of field usage:
		if field always OR'd or AND'd with 0x1, 0x2, 0x4, etc, it is a bit field/flags
		if value compared against a number, it is an int
	as you go down the struct, you go higher in address. this means base of the struct is at the top

floats
there is a special hardware stack for handling floats. this is the FPU (floating point unit) register stack

structs containing arrays
	[esi + edi*4 + 0x18]: esi+0x18 is the base and then edi is index and 4 is size of each element in the array

approaches for source code auditing:
	starting with main() - good for small programs or malware, bad for large programs
	starting with user-controlled input - good for finding vulnerabilities. easy to find
	finding particular strings and recognisable constructs - strings like "enter serial key"
	using strace and ltrace

SHELLCODE DEVELOPMENT

shellcode is a small piece of code in a payload that gives you a show.
usually written in machine code
after a memory corruption based exploit we need a way to execute code
	1. shellcode
	2. ROP/RET2LIBC, etc

now instead of overwriting with garbage, we put shellcode, and then eip will jump to the base of our shellcode

uses of shellcode:
	execve("/bin/sh", NULL, NULL);
	connect back (reverse shell) - victim machine talks back to attacker
	socket reuse - reuse socket we used to deliver exploit
	egghunter - small bit of shellcode that find a larger payload. this is useful since buffers to store shellcode is usually small
	download a second stage exploit

shellcode needs to be position independent. it won't know where it is in memory so hardcoded memory addresses can't be used (needs to be relative)
pop eax, can be used to load eip into eax and then we can use relative offsets
shellcode is written in bytes that equate to assembly instructions

how to get shellcode bytes:
	write asm by hand, assemble with nasm and grab the bytes
	write in c, compile (-static) and grep
	python + pwntools using asm()

running syscalls
	put syscall number in eax (1 for sys_exit etc)
	then trigger with interrupt (int 0x80)
	arguments are passed to syscall through registers in order (ebx, ecx, edx, esi, edi)

syscall table: cgi.cse.unsw.edu.au/~

AVOID NULL BYTES IN SHELLCODE. this will cause things like strcpy to end

what if we need strings as inputs?
	1. use the stack with pop/push. we can put strings onto the stack and take value of esp to get address of the string. Note that push/pop works with 4 bytes at a time so the string needs to be padded.
	2. add the string at the end of the shellcode and offset from the address of your shellcode

NOP sleds
	we don't usually know the exect start of shellcode
	so we use NOP instructions which do nothing
	the idea is we place a bunch of NOPs (the sled) then our shellcode
	we jump somewhere in the NOP sled and then all the NOPs get executed until our shellcode is reached
	note some firewalls block 10,000 NOPs.
	but we can just replace with other useless instructions like "xchg eax, eax"

syscall proxy

egghunter
	useful when a program has one large and one tiny buffer. tiny overlfows
	in the tiny buffer put shellcode that loops through memory looking for large buffer, then execute
	in big buffer put a signature (like 0xABCDEF1234) then normal shellcode

NX (non executable stack) - memory protection that targets shellcode developers
how to deal with this
	mprotect
	we can make just our chunk executable


FORMAT STRINGS
these vulnerabilities are easy to find with grep or static checks

format string processing:
	not % - copied unchanged into output stream
	% - fetch next argument from stack, and do output converstion
	%<flags><width><precision><modifier><type>
	width - minimum number of characters (uses padding) - if you give this as * then it uses a parameter to work out the width
	precision - specified things like decimal points
	modifier - includes things like $ which lets you specify how many times to print something

types of format types:
	%d - integer
	%c - char
	%p - pointer
	%s - pointer and dereference
	%x - prints integer as hex
	%n - number of characters written so far is stored into an integer which is then outputted

format string vuln can be used to:
	crash programs/servers - through segfaults
	leaking information - stack canaries, memory addresses, etc
	Overwriting memory and variables
	dump entire process memory

blind format string attack - given a port can leak the whole binary

when you enter in data that is later printed remember. your buffer is on the stack. you just need to tell printf how to interpret the data of this buffer.
this is a MEMORY READ PRIMITIVE

format string tactic:
	print AAAA and then a bunch of %x
	eventually you should find 0x41414141 which indicates where your buffer starts in the stack
	The number of A's may need to be adjusted to make 4-byte alignment

arbitrary writes
	if we want to write 100 to 0x12345678: '\x78\x56\x34\x12 %95$x%n'
	the 100 comes from 4 bytes at beginning, then a space then 95 width %x
	writing a large number like 0xFFFFFFFF to load an address would take too long
	so we write one of 2 bytes at a time with:
		%hhn - hh modifier does integer conversion to unsigned char (1 byte)
		%hn - h modifier does integer conversion to short (2 bytes)

issues with splitting writes:
	payload becomes longer and might not fit in buffer
	if a future write needs to be smaller?? - we just overflow and then the hhn will truncate the lsb's

fun places to write to:
	PLT/GOT
	dtors
	C lib hooks
	__atexit handlers
	function ptrs, jump tables

GOT - global offset table
	this table maps library function addresses to addresses used in the program
	every lib function has an entry in the GOT
	initially contains address of RTL (runtime linker)
	RTL resolves real address and replaces the entry on the first cal

what do we write:
	if we have a function that pops a shell, we can overwrite GOT to point to it
	else we could write shellcode and overwrite a function pointer to jump to our code

other functions use format strings:
	syslog
	sprintf
	scanf

potential issues:
if the address you are trying to write to contains \x00 this will terminate printf
to overcome this you put you %x and %n first and the address at the end
since we don't care if the address are printed


MEMORY PROTECTION

types of protection:
1. stop you corrupting memory
	a) stack reordering/random padding
	b) stack canary
	c) FORTIFY
	d) RELRO
	e) writing good code
	f) testing)
2. stop you gaining code exec after memory corruption
	a) ASLR/PIE randomisation
	b) NX
	c) pointer authentication

ASLR - address space layout randomisation
when a new process executes, every memory region gets an ASLR SLIDE
	a random number aligned to a boundary (final byte 00)
	everything inside the region is relatively the same only the base moves
this is system wide and can't be disabled on a per program basis
it tries to increase entropy (need to gues xx bits to get a correct address)

PIE - position independent execution
similary to ASLR but for the text/code region
this is program specific and need to be set in compile options
	ensures programs can't contain jumps to static addresses
	gcc usually sets EBX to the base of the binary and offsets global variables from that
if ASLR is disabled system wide, PIE is disabled

the solution to attack PIE and ASLR is to leak an address

patterns:
	0x565.. - binary base with PIE ENABLED
	0x804.. - binary base with PIE DISABLED
	0xf7f.. - library base
	0xff... - stack base

non executable stack / NX / W^X (only writeable or executable)
can't write code then execute it by default
if you try execute non executable code, it will die or crash
this is enforce by hardware
can be bypassed with ROP/RET2code/RET2libc

RELRO - RELocation Read-Only
hardens elf binaries
full RELRO makes GOT read only
partial RELRO is pretty useless. it just forces GOT to come after BSS in memory, eliminating risk of buffer overflow

Fortify
combats things like format string exploits
	does lightweight checks to detect buffer overflows by using string and memory manipulation functions
it only allows %n when format string is in read only memory

Pointer Authentication (PAC)
introduced in ARM 8.3
used to detect pointers created by an external entity
when you want to jump to address X you jump to a signed version of the address
the address is calculated from:
	pointer itself
	secret key hidden in the process context
	3rd value like currest stack pointer

SOURCE CODE AUDITING

why do we read the source
	1. best way to find bugs
	2. easier than reversing assembly
	3. find more bugs than from fuzzing and input manipulation

classes of problems in source:
	bad api usage - wrong order of parameters like memset(void *s, int c, size_t n)
	logic bugs
	integer overflows
	type conversions
	array out of bounds
	incorrect use of operators
	not understanding pointer arithmetic
	race conditions

source auditing is like reversing:
	look at the big picture
	audit function you know aren't safe (printf, scanf)
	make a list of interesting functions as you audit. don't jump around too much
	bottom up approach - start at user input
	read the manual


FUZZING

fuzzing or fuzz testing is an automated testing technique that involves providing invalid, unexpected or random data as inputs to a program
can be used for standard unit testing

fuzzing is used to automate the finding of vulnerabilities by generating test cases, sending them to program and monitoring changes
goal is to get the most code coverage by testing as many paths as possible

usually fuzzers take a sample input and mutate it

we want the fuzzer to try cause program crashes, hangs/infinite loops, and unique error codes

fuzzing limitations
	non crashing bugs are hard to detect
		arbitrary read/write
		sql injections
		privilege escalation
	hard to know your progress
		if there are no crashes for a while, are there no bugs or is the fuzzer broken?
		if there are lots of crashes, maybe the fuzzer is triggering the same bug over and over and not finding more useful bugs

quickcheck - haskell test generator that acts like a fuzzer. it finds some input that causes issue then reduces it to the most simple case that causes the same bug.

fuzzing has 2 parts:
	the fuzzer - attaches to program and sends mutated input
	the harness - monitors for crashes and record what inputs caused what crash. harness will look for crashes, weird program states, code coverage, error messages and information leaks.

example harnesses:
	debugger
	code coverage
	hypervisor
	return code

echo $? returns the error code

how to write a fuzzer

start by just runnign the program
write a tool that takes some data, mutates it and saves the mutated file
run the program to parse the mutated file
did the program crash?
	attach gdb, enable core dumps or look at return codes
however this can't scale if the program relies on one file

AFL - american fuzzy lop
Libfuzzer

to find more important bugs add hooks at the points where there are overflows etc

Address Sanitizer crashes a program on invalid memory writes/reads

mutation based fuzzing - trying random inputs. dumb but easy
generation based fuzzing - smart but hard



ROP - RETURN ORIENTED PROGRAMMING

ROP is a turing complete method of writing programs without any code
weird machine - computational artifact where additional code executation can happen outside of original program spec

ROP works by chaining together tiny parts of code in an existing program

important thing to bear in mind is structure of stack for each function call:
	address of function to call
	return address for function call
	arg1 for function
	arg 2
	etc

when NX is enabled we can't use shellcode
so we can use ROP with code from the .TEXT or library sections

gadgets for ROP
gadget is a small set of instructions that does a certain task
gadgets usually end with a ret or a jmp/call instruction
we used these gadgets to make a ROP CHAIN
recall that ret will jump to the address at the top of the stack

instructions can overlap
example
	opcode 66 90 = xchg ax, ax
	opcode 90 = nop

we can jump to parts of an opcode since x86 instructions can be between 1 and 15 bytes
kind of like huffman encoding, it is guaranteed that for example only 1 instruction can start with F2 F0, and it can't represent another instruction on its own

POP POP RET gadget
we can set return address of a function to be that gadget
then the 2 args get taken off the stack
then return to the next address on the stack

ret2code - returning to code gadgets defined in the program
ret2libc - return to code gadgets in libc (system, fread, fopen)
ret2xxx - return to code in some part of the program
ROP - calling functions you create yourself with gadgets

ROP requires binaries with the right gadgets or libc to be linked in and be leakable

calling execve with RIP
we need:
	gadget to control eax (syscall number)
	gadget to control edi (arg 1)
	gadget to control esi, edx (arg 2,3)
	int 0x80 gadget


Stack Pivots
somtimes you may have a large ROP chain and the buffer can't fit it all
a pivot is used to move the stack pointer somewhere else
	1. use a gadget like sub esp, 0x80
	2. use a partial/complete overwrite of EBP on the stack

RETSLED
stack pivot might not be exact so we can use a RETSLED
address to a ret gadget returns to next address which is also the ret gadget.
this continues until we reach our ROP chain

Automating ROP chains (not allowed in course)
	symbolic execution
		analyzing a program to determine what inputs cause each part of a program to execute
		used to understand effect of gadgets
	constraint satisfaction problems

	SAT solver

angrop
angr is a python framework for analysing binaries (uses static and dynamic symbol analysis)
angrop is a rop gadget finder and chain builder
it uses z3 SAT solver


HEAP EXPLOITATION

Heap exploitation often involves attacking the implementation of heaps, so exploits are often specific to systems.
As a result, heap exploitation is linked to your libc version

What is malloc
	dlmalloc - general purpose allocation
	ptmalloc2 - glibc
		-fast for multithreaded apps and small allocations
	jemalloc - firefox
	tcmalloc - chrome
		- faster when threads are created/destructed
		- uses a shit ton of memory

The heap memory segment is used for dynamic allocations. Blocks of memory can be allocated an freed in an arbitrary order and accessed multiple times
Unlike stack, memory allocated to the heap must be explicity de-allocated when the data isn't needed

malloc is a first-fit allocated
	searches recently free chunks and then new chunks
	stores metadata before/after data
	split into free and not free chunks

glibc's malloc is chunk oriented
	chunk is an allocated piece of memory and uses metadata for:
		how big the chunk is
		where the adjacent chunks are
	when a chunk is in use, the only metadata kept is the size of the chunk

the size of the chunk includes the metadata
minimum chunk size is 4*sizeof(void*)
so in 32bit this is 0x10
all chunk sizes are aligned to 8 byte boundaries.
valid chunk sizes are 0x10, 0x18, 0x20, 0x28, etc
last 3 bits of size are unused so these bits are used to store information
	bit 1 - 1 if chunk is in main arena (A)
	bit 2 - 1 if chunk is mmap'ed (M)
	bit 3 - 1 if previous chunk is in use (P)

in-use chunk metadata
	prev_size
	size, AMP
	payload

free chunk metadata
	prev_size
	size, AMP
	fwd
	bck
	fd_nextsize (large chunks only)
	bk_nextsize (large chunks only)
	prev_size (same as size)

within an arena (thread?) chunks are either in use or free
in-use chunks are not tracked by the arena
free chunks are stored in various lists based on size and history

Freeing chunks
free needs to be fast
implemented with different sized bins
smaller chunks have less secure bins (faster to deallocate)
bins are arrays of linked lists of chunks
the nodes in the linked lists are old chunks

Fast bins
	small chunks are stored in size-specific bins
	chunks added to fastbin are not combined with adjacent chunks
	fastbin chunks are stored in single linked list since they're all the same size
	10 fastbins - size 16, 24, 32, etc
note that malloc will search through cached fastbins first

unsorted bins
	when chunks are free'd they're initially stored in a single bin
	they're later sorted in malloc to give them ONE chance to be quickly reused

other bins
	normal bins are divided into 62 "small" bins and "large" bins
	small bins have same sized chunks, large bins have a small range of chunk sizes
	when a chunk is added to these bins, they're first combined with adjacent chunks to coalesce into larger chunks.
	small are large chunks are doubly-linked so they can be merged

tcache bin
	introduced in 2017 glibc
	this is a thread local cache
	similar to fastbins but less checks
	easy to hack and double free is easy
	there are no checks on header
	in 2019 checks for double frees were added
	unlike fastbins, the tcache is limited in how many chunks are allowed in each bin (around 7)
	if tcache bin is emply for a given requested size, normal malloc routine is used

if chunks in bins are broken off, the remainder may have to be moved into another chunk
when a chunk is freed, it is prepended to the free linked list


EXPLOITING THE HEAP

heap exploitation techniques:
	double free
	forging chunks
	unlink
	shrinking free chunks
	house of spirit
	house of love
	house of force
most of the time the goal is to make malloc return an arbitrary pointer

use after free
when you free memory and then use it
how this can be abused:
	corrupt free linked list structure
	change the free structures so we can allocate our own memory
if you use after free and write memory to a free chunk, you overwrite the forward pointer.

double free
when you free twice, the same chunk is added to the free list twice (through appends). however there needs to be another free in between else gcc won't allow it.
then when you start mallocing there will be 2 writes to the same address so you can overwrite data possibly.
can also create a circular free list

a small chunk is in a bin that is a doubly linked list. the first element points back into libc
so if you can leak the first 4 bytes of a free small chunk, you have leaked an address to libc

forging chunks
setup required is 2 chunks next to each other where the first has a buffer overflow
2 cases
	if 2nd chunk is free:
		can overflow into freelist metadata and cause new chunks to be allocated
	if 2nd chunk in use
		can overflow into chunk metadata
		modify size and cause chunk to be put in different sized bin
		can be used to convert fastbin into smallbin, then leak an address with it
what you can do with a corrupted chunk
	create fake chunk pointing to a function pointer
	overwrite function pointer with our own

malloc hook functions
its a global function pointer in every program
calling malloc calls __malloc_hook
if you can control __malloc_hook, everytime someone calls malloc, they're calling your code
could make malloc hook call a one gadget

one gadget is a single gadget that can pop a shell if given constraints are satisfied

heap spraying


House of Einherjar (complex heap overflow)
only requires a 1 byte overflow
useful in off by one bugs



